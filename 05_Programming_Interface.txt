== Programming Interface

=== Block Cipher Context Data Structures

<<aead_request, struct aead_request>> - AEAD request

These data structures define the operating context for each block cipher type. 

<<<

[[aead_request]]
*Name*

struct aead_request — AEAD request 

*Synopsis*

[source,c]
---------------
struct aead_request {
  struct crypto_async_request base;
  unsigned int assoclen;
  unsigned int cryptlen;
  u8 * iv;
  struct scatterlist * assoc;
  struct scatterlist * src;
  struct scatterlist * dst;
  void * __ctx[] CRYPTO_MINALIGN_ATTR;
};  
---------------

*Members*

base::
  Common attributes for async crypto requests 
assoclen::
  Length in bytes of associated data for authentication 
cryptlen::
  Length of data to be encrypted or decrypted 
iv::
  Initialisation vector 
assoc::
  Associated data 
src::
  Source data 
dst::
  Destination data 
__ctx[] CRYPTO_MINALIGN_ATTR::
  Start of private context data 

<<<

=== Block Cipher Algorithm Definitions

<<crypto_alg, struct crypto_alg>> — definition of a cryptograpic cipher algorithm +
<<ablkcipher_alg, struct ablkcipher_alg>> — asynchronous block cipher definition +
<<aead_alg, struct aead_alg>> — AEAD cipher definition +
<<blkcipher_alg, struct blkcipher_alg>> — synchronous block cipher definition +
<<cipher_alg, struct cipher_alg>> — single-block symmetric ciphers definition +
<<rng_alg, struct rng_alg>> — random number generator definition

These data structures define modular crypto algorithm implementations, managed via crypto_register_alg and crypto_unregister_alg. 

[[crypto_alg]]
*Name*

struct crypto_alg — definition of a cryptograpic cipher algorithm

.Synopsis
[source,c]
------------------
struct crypto_alg {
  struct list_head cra_list;
  struct list_head cra_users;
  u32 cra_flags;
  unsigned int cra_blocksize;
  unsigned int cra_ctxsize;
  unsigned int cra_alignmask;
  int cra_priority;
  atomic_t cra_refcnt;
  char cra_name[CRYPTO_MAX_ALG_NAME];
  char cra_driver_name[CRYPTO_MAX_ALG_NAME];
  const struct crypto_type * cra_type;
  union cra_u;
  int (* cra_init) (struct crypto_tfm *tfm);
  void (* cra_exit) (struct crypto_tfm *tfm);
  void (* cra_destroy) (struct crypto_alg *alg);
  struct module * cra_module;
};  
------------------

*Members*

cra_list::
  internally used 
cra_users::
  internally used 
cra_flags::
  Flags describing this transformation. See include/linux/crypto.h CRYPTO_ALG_* flags for the flags which go in here. Those are used for fine-tuning the description of the transformation algorithm. 
cra_blocksize::
  Minimum block size of this transformation. The size in bytes of the smallest possible unit which can be transformed with this algorithm. The users must respect this value. In case of HASH transformation, it is possible for a smaller block than cra_blocksize to be passed to the crypto API for transformation, in case of any other transformation type, an error will be returned upon any attempt to transform smaller than cra_blocksize chunks. 
cra_ctxsize::
  Size of the operational context of the transformation. This value informs the kernel crypto API about the memory size needed to be allocated for the transformation context. 
cra_alignmask::
  Alignment mask for the input and output data buffer. The data buffer containing the input data for the algorithm must be aligned to this alignment mask. The data buffer for the output data must be aligned to this alignment mask. Note that the Crypto API will do the re-alignment in software, but only under special conditions and there is a performance hit. The re-alignment happens at these occasions for different 
cra_priority::
  Priority of this transformation implementation. In case multiple transformations with same cra_name are available to the Crypto API, the kernel will use the one with highest cra_priority. 
cra_refcnt::
  internally used 
cra_name[CRYPTO_MAX_ALG_NAME]::
  Generic name (usable by multiple implementations) of the transformation algorithm. This is the name of the transformation itself. This field is used by the kernel when looking up the providers of particular transformation. 
cra_driver_name[CRYPTO_MAX_ALG_NAME]::
  Unique name of the transformation provider. This is the name of the provider of the transformation. This can be any arbitrary value, but in the usual case, this contains the name of the chip or provider and the name of the transformation algorithm. 
cra_type::
  Type of the cryptographic transformation. This is a pointer to struct crypto_type, which implements callbacks common for all trasnformation types. There are multiple options: crypto_blkcipher_type, crypto_ablkcipher_type, crypto_ahash_type, crypto_aead_type, crypto_rng_type. This field might be empty. In that case, there are no common callbacks. This is the case for: cipher, compress, shash. 
cra_u::
  Callbacks implementing the transformation. This is a union of multiple structures. Depending on the type of transformation selected by cra_type and cra_flags above, the associated structure must be filled with callbacks. This field might be empty. This is the case for ahash, shash. 
cra_init::
  Initialize the cryptographic transformation object. This function is used to initialize the cryptographic transformation object. This function is called only once at the instantiation time, right after the transformation context was allocated. In case the cryptographic hardware has some special requirements which need to be handled by software, this function shall check for the precise requirement of the transformation and put any software fallbacks in place. 
cra_exit::
  Deinitialize the cryptographic transformation object. This is a counterpart to cra_init, used to remove various changes set in cra_init. 
cra_destroy::
  internally used 
cra_module::
  Owner of this transformation implementation. Set to THIS_MODULE 

*Description*

The struct crypto_alg describes a generic Crypto API algorithm and is common for all of the transformations. Any variable not documented here shall not be used by a cipher implementation as it is internal to the Crypto API. 

<<<

[[ablkcipher_alg]]
*Name*

struct ablkcipher_alg — asynchronous block cipher definition

.Synopsis
[source,c]
-------------------
struct ablkcipher_alg {
  int (* setkey) (struct crypto_ablkcipher *tfm, const u8 *key,unsigned int keylen);
  int (* encrypt) (struct ablkcipher_request *req);
  int (* decrypt) (struct ablkcipher_request *req);
  int (* givencrypt) (struct skcipher_givcrypt_request *req);
  int (* givdecrypt) (struct skcipher_givcrypt_request *req);
  const char * geniv;
  unsigned int min_keysize;
  unsigned int max_keysize;
  unsigned int ivsize;
};  
-------------------

*Members*

setkey::
  Set key for the transformation. This function is used to either program a supplied key into the hardware or store the key in the transformation context for programming it later. Note that this function does modify the transformation context. This function can be called multiple times during the existence of the transformation object, so one must make sure the key is properly reprogrammed into the hardware. This function is also responsible for checking the key length for validity. In case a software fallback was put in place in the cra_init call, this function might need to use the fallback if the algorithm doesn't support all of the key sizes. 
encrypt::
  Encrypt a scatterlist of blocks. This function is used to encrypt the supplied scatterlist containing the blocks of data. The crypto API consumer is responsible for aligning the entries of the scatterlist properly and making sure the chunks are correctly sized. In case a software fallback was put in place in the cra_init call, this function might need to use the fallback if the algorithm doesn't support all of the key sizes. In case the key was stored in transformation context, the key might need to be re-programmed into the hardware in this function. This function shall not modify the transformation context, as this function may be called in parallel with the same transformation object. 
decrypt::
  Decrypt a single block. This is a reverse counterpart to encrypt and the conditions are exactly the same. 
givencrypt::
  Update the IV for encryption. With this function, a cipher implementation may provide the function on how to update the IV for encryption. 
givdecrypt::
  Update the IV for decryption. This is the reverse of givencrypt . 
geniv::
  The transformation implementation may use an “IV generator” provided by the kernel crypto API. Several use cases have a predefined approach how IVs are to be updated. For such use cases, the kernel crypto API provides ready-to-use implementations that can be referenced with this variable. 
min_keysize::
  Minimum key size supported by the transformation. This is the smallest key length supported by this transformation algorithm. This must be set to one of the pre-defined values as this is not hardware specific. Possible values for this field can be found via git grep “_MIN_KEY_SIZE” include/crypto/ 
max_keysize::
  Maximum key size supported by the transformation. This is the largest key length supported by this transformation algorithm. This must be set to one of the pre-defined values as this is not hardware specific. Possible values for this field can be found via git grep “_MAX_KEY_SIZE” include/crypto/ 
ivsize::
  IV size applicable for transformation. The consumer must provide an IV of exactly that size to perform the encrypt or decrypt operation. 

*Description*

All fields except givencrypt , givdecrypt , geniv and ivsize are mandatory and must be filled. 

<<<

[[aead_alg]]
*Name*

struct aead_alg — AEAD cipher definition

.Synopsis
[source,c]
------------------
struct aead_alg {
  int (* setkey) (struct crypto_aead *tfm, const u8 *key,unsigned int keylen);
  int (* setauthsize) (struct crypto_aead *tfm, unsigned int authsize);
  int (* encrypt) (struct aead_request *req);
  int (* decrypt) (struct aead_request *req);
  int (* givencrypt) (struct aead_givcrypt_request *req);
  int (* givdecrypt) (struct aead_givcrypt_request *req);
  const char * geniv;
  unsigned int ivsize;
  unsigned int maxauthsize;
};  
------------------

*Members*

setkey::
  see struct ablkcipher_alg 
setauthsize::
  Set authentication size for the AEAD transformation. This function is used to specify the consumer requested size of the authentication tag to be either generated by the transformation during encryption or the size of the authentication tag to be supplied during the decryption operation. This function is also responsible for checking the authentication tag size for validity. 
encrypt::
  see struct ablkcipher_alg 
decrypt::
  see struct ablkcipher_alg 
givencrypt::
  see struct ablkcipher_alg 
givdecrypt::
  see struct ablkcipher_alg 
geniv::
  see struct ablkcipher_alg 
ivsize::
  see struct ablkcipher_alg 
maxauthsize::
  Set the maximum authentication tag size supported by the transformation. A transformation may support smaller tag sizes. As the authentication tag is a message digest to ensure the integrity of the encrypted data, a consumer typically wants the largest authentication tag possible as defined by this variable. 

*Description*

All fields except givencrypt , givdecrypt , geniv and ivsize are mandatory and must be filled. 

<<<

struct blkcipher_alg

[[blkcipher_alg]]
*Name*

struct blkcipher_alg — synchronous block cipher definition

.Synopsis
[source,c]
----------------
struct blkcipher_alg {
  int (* setkey) (struct crypto_tfm *tfm, const u8 *key,unsigned int keylen);
  int (* encrypt) (struct blkcipher_desc *desc,struct scatterlist *dst, struct scatterlist *src,unsigned int nbytes);
  int (* decrypt) (struct blkcipher_desc *desc,struct scatterlist *dst, struct scatterlist *src,unsigned int nbytes);
  const char * geniv;
  unsigned int min_keysize;
  unsigned int max_keysize;
  unsigned int ivsize;
};  
----------------

*Members*

setkey::
  see struct ablkcipher_alg 
encrypt::
  see struct ablkcipher_alg 
decrypt::
  see struct ablkcipher_alg 
geniv::
  see struct ablkcipher_alg 
min_keysize::
  see struct ablkcipher_alg 
max_keysize::
  see struct ablkcipher_alg 
ivsize::
  see struct ablkcipher_alg 

*Description*

All fields except geniv and ivsize are mandatory and must be filled. 

<<<

[[cipher_alg]]
*Name*

struct cipher_alg — single-block symmetric ciphers definition

.Synopsis
[source,c]
-----------------
struct cipher_alg {
  unsigned int cia_min_keysize;
  unsigned int cia_max_keysize;
  int (* cia_setkey) (struct crypto_tfm *tfm, const u8 *key,unsigned int keylen);
  void (* cia_encrypt) (struct crypto_tfm *tfm, u8 *dst, const u8 *src);
  void (* cia_decrypt) (struct crypto_tfm *tfm, u8 *dst, const u8 *src);
};  
-----------------

*Members*

cia_min_keysize::
  Minimum key size supported by the transformation. This is the smallest key length supported by this transformation algorithm. This must be set to one of the pre-defined values as this is not hardware specific. Possible values for this field can be found via git grep “_MIN_KEY_SIZE” include/crypto/ 
cia_max_keysize::
  Maximum key size supported by the transformation. This is the largest key length supported by this transformation algorithm. This must be set to one of the pre-defined values as this is not hardware specific. Possible values for this field can be found via git grep “_MAX_KEY_SIZE” include/crypto/ 
cia_setkey::
  Set key for the transformation. This function is used to either program a supplied key into the hardware or store the key in the transformation context for programming it later. Note that this function does modify the transformation context. This function can be called multiple times during the existence of the transformation object, so one must make sure the key is properly reprogrammed into the hardware. This function is also responsible for checking the key length for validity. 
cia_encrypt::
  Encrypt a single block. This function is used to encrypt a single block of data, which must be cra_blocksize big. This always operates on a full cra_blocksize and it is not possible to encrypt a block of smaller size. The supplied buffers must therefore also be at least of cra_blocksize size. Both the input and output buffers are always aligned to cra_alignmask. In case either of the input or output buffer supplied by user of the crypto API is not aligned to cra_alignmask, the crypto API will re-align the buffers. The re-alignment means that a new buffer will be allocated, the data will be copied into the new buffer, then the processing will happen on the new buffer, then the data will be copied back into the original buffer and finally the new buffer will be freed. In case a software fallback was put in place in the cra_init call, this function might need to use the fallback if the algorithm doesn't support all of the key sizes. In case the key was stored in transformation context, the key might need to be re-programmed into the hardware in this function. This function shall not modify the transformation context, as this function may be called in parallel with the same transformation object. 
cia_decrypt::
  Decrypt a single block. This is a reverse counterpart to cia_encrypt, and the conditions are exactly the same. 

*Description*

All fields are mandatory and must be filled. 

<<<

[[rng_alg]]
*Name*

struct rng_alg — random number generator definition

.Synopsis
[source,c]
---------------
struct rng_alg {
  int (* rng_make_random) (struct crypto_rng *tfm, u8 *rdata,unsigned int dlen);
  int (* rng_reset) (struct crypto_rng *tfm, u8 *seed, unsigned int slen);
  unsigned int seedsize;
};  
---------------

*Members*

rng_make_random::
  The function defined by this variable obtains a random number. The random number generator transform must generate the random number out of the context provided with this call. 
rng_reset::
  Reset of the random number generator by clearing the entire state. With the invocation of this function call, the random number generator shall completely reinitialize its state. If the random number generator requires a seed for setting up a new state, the seed must be provided by the consumer while invoking this function. The required size of the seed is defined with seedsize . 
seedsize::
  The seed size required for a random number generator initialization defined with this variable. Some random number generators like the SP800-90A DRBG does not require a seed as the seeding is implemented internally without the need of support by the consumer. In this case, the seed size is set to zero. 

<<<

=== Asynchronous Block Cipher API

<<crypto_alloc_ablkcipher, struct crypto_alloc_ablkcipher>> — allocate asynchronous block cipher handle +
<<crypto_free_ablkcipher, crypto_free_ablkcipher>> — zeroize and free cipher handle +
<<crypto_has_ablkcipher, crypto_has_ablkcipher>> — Search for the availability of an ablkcipher. +
<<crypto_ablkcipher_ivsize, crypto_ablkcipher_ivsize>> — obtain IV size +
<<crypto_ablkcipher_blocksize, crypto_ablkcipher_blocksize>> — obtain block size of cipher +
<<crypto_ablkcipher_setkey, crypto_ablkcipher_setkey>> — set key for cipher +
<<crypto_ablkcipher_reqtfm, crypto_ablkcipher_reqtfm>> — obtain cipher handle from request +
<<crypto_ablkcipher_encrypt, crypto_ablkcipher_encrypt>> — encrypt plaintext +
<<crypto_ablkcipher_decrypt, crypto_ablkcipher_decrypt>> — decrypt ciphertext 

Asynchronous block cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_ABLKCIPHER (listed as type “ablkcipher” in /proc/crypto).

Asynchronous cipher operations imply that the function invocation for a cipher request returns immediately before the completion of the operation. The cipher request is scheduled as a separate kernel thread and therefore load-balanced on the different CPUs via the process scheduler. To allow the kernel crypto API to inform the caller about the completion of a cipher request, the caller must provide a callback function. That function is invoked with the cipher handle when the request completes.

To support the asynchronous operation, additional information than just the cipher handle must be supplied to the kernel crypto API. That additional information is given by filling in the ablkcipher_request data structure.

For the asynchronous block cipher API, the state is maintained with the tfm cipher handle. A single tfm can be used across multiple calls and in parallel. For asynchronous block cipher calls, context data supplied and only used by the caller can be referenced the request data structure in addition to the IV used for the cipher request. The maintenance of such state information would be important for a crypto driver implementer to have, because when calling the callback function upon completion of the cipher operation, that callback function may need some information about which operation just finished if it invoked multiple in parallel. This state information is unused by the kernel crypto API. 

<<<

[[crypto_alloc_ablkcipher]]
*Name*

crypto_alloc_ablkcipher — allocate asynchronous block cipher handle

.Synopsis
[source,c]
------------------
struct crypto_ablkcipher * crypto_alloc_ablkcipher (const char * alg_name,
 	u32 type,
 	u32 mask);
------------------
 
*Arguments*

alg_name::
  is the cra_name / name or cra_driver_name / driver name of the ablkcipher cipher 
type::
  specifies the type of the cipher 
mask::
  specifies the mask for the cipher 

*Description*

Allocate a cipher handle for an ablkcipher. The returned struct crypto_ablkcipher is the cipher handle that is required for any subsequent API invocation for that ablkcipher.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_ablkcipher]]
*Name*

crypto_free_ablkcipher — zeroize and free cipher handle

.Synopsis
[source,c]
---------------
void crypto_free_ablkcipher (struct crypto_ablkcipher * tfm);
---------------
 
*Arguments*

tfm::
  cipher handle to be freed 

<<<

[[crypto_has_ablkcipher]]
*Name*
crypto_has_ablkcipher — Search for the availability of an ablkcipher.

.Synopsis
[source,c]
----------------
int crypto_has_ablkcipher (const char * alg_name,
 	u32 type,
 	u32 mask);
----------------
 
*Arguments*

alg_name::
  is the cra_name / name or cra_driver_name / driver name of the ablkcipher 
type::
  specifies the type of the cipher 
mask::
  specifies the mask for the cipher 

*Return*

true when the ablkcipher is known to the kernel crypto API; false otherwise 

<<<

[[crypto_ablkcipher_ivsize]]
*Name*

crypto_ablkcipher_ivsize — obtain IV size

.Synopsis
[source,c]
-----------------
unsigned int crypto_ablkcipher_ivsize (struct crypto_ablkcipher * tfm);
-----------------
 
.Arguments

tfm::
  cipher handle 

*Description*

The size of the IV for the ablkcipher referenced by the cipher handle is returned. This IV size may be zero if the cipher does not need an IV.

*Return*

IV size in bytes 

<<<

[[crypto_ablkcipher_blocksize]]
*Name*

crypto_ablkcipher_blocksize — obtain block size of cipher

.Synopsis
[source,c]
-----------------
unsigned int crypto_ablkcipher_blocksize (struct crypto_ablkcipher * tfm);
-----------------
 
*Arguments*

tfm::
  cipher handle 

*Description*

The block size for the ablkcipher referenced with the cipher handle is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation

*Return*

block size of cipher 

<<<

[[crypto_ablkcipher_setkey]]
*Name*

crypto_ablkcipher_setkey — set key for cipher

.Synopsis
[source,c]
------------------
int crypto_ablkcipher_setkey (struct crypto_ablkcipher * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------------
 
*Arguments*

tfm::
  cipher handle 
key::
  buffer holding the key 
keylen::
  length of the key in bytes 

*Description*

The caller provided key is set for the ablkcipher referenced by the cipher handle.
Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_ablkcipher_reqtfm]]
*Name*

crypto_ablkcipher_reqtfm — obtain cipher handle from request

.Synopsis
[source,c]
------------------
struct crypto_ablkcipher * crypto_ablkcipher_reqtfm (struct ablkcipher_request * req);
------------------
 
.Arguments

req::
  ablkcipher_request out of which the cipher handle is to be obtained 

*Description*

Return the crypto_ablkcipher handle when furnishing an ablkcipher_request data structure.

*Return*

crypto_ablkcipher handle 

<<<

[[crypto_ablkcipher_encrypt]]
*Name*

crypto_ablkcipher_encrypt — encrypt plaintext

.Synopsis
[source,c]
--------------
int crypto_ablkcipher_encrypt (struct ablkcipher_request * req);
--------------
 
*Arguments*

req::
  reference to the ablkcipher_request handle that holds all information needed to perform the cipher operation 

*Description*

Encrypt plaintext data using the ablkcipher_request handle. That data structure and how it is filled with data is discussed with the ablkcipher_request_* functions.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_ablkcipher_decrypt]]
*Name*
crypto_ablkcipher_decrypt — decrypt ciphertext

.Synopsis
[source,c]
------------
int crypto_ablkcipher_decrypt (struct ablkcipher_request * req);
------------
 
.Arguments
req::
  reference to the ablkcipher_request handle that holds all information needed to perform the cipher operation 

*Description*

Decrypt ciphertext data using the ablkcipher_request handle. That data structure and how it is filled with data is discussed with the ablkcipher_request_* functions.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

=== Asynchronous Cipher Request Handle

<<crypto_ablkcipher_reqsize, crypto_ablkcipher_reqsize>> — obtain size of the request data structure +
<<ablkcipher_request_set_tfm, ablkcipher_request_set_tfm>> — update cipher handle reference in request +
<<ablkcipher_request_alloc, ablkcipher_request_alloc>> — allocate request data structure +
<<ablkcipher_request_free, ablkcipher_request_free>> — zeroize and free request data structure +
<<ablkcipher_request_set_callback, ablkcipher_request_set_callback>> — set asynchronous callback function +
<<ablkcipher_request_set_crypt, ablkcipher_request_set_crypt>> — set data buffers 

The ablkcipher_request data structure contains all pointers to data required for the asynchronous cipher operation. This includes the cipher handle (which can be used by multiple ablkcipher_request instances), pointer to plaintext and ciphertext, asynchronous callback function, etc. It acts as a handle to the ablkcipher_request_* API calls in a similar way as ablkcipher handle to the crypto_ablkcipher_* API calls. 

<<<

[[crypto_ablkcipher_reqsize]]
*Name*

crypto_ablkcipher_reqsize — obtain size of the request data structure

.Synopsis
[source,c]
------------
unsigned int crypto_ablkcipher_reqsize (struct crypto_ablkcipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Return*

number of bytes 

<<<

[[ablkcipher_request_set_tfm]]
*Name*

ablkcipher_request_set_tfm — update cipher handle reference in request

.Synopsis
[source,c]
------------
void ablkcipher_request_set_tfm (struct ablkcipher_request * req,
 	struct crypto_ablkcipher * tfm);
------------
 
*Arguments*

req::
    request handle to be modified 
tfm::
    cipher handle that shall be added to the request handle 

*Description*

Allow the caller to replace the existing ablkcipher handle in the request data structure with a different one. 

<<<

[[ablkcipher_request_alloc]]
*Name*

ablkcipher_request_alloc — allocate request data structure

.Synopsis
[source,c]
------------
struct ablkcipher_request * ablkcipher_request_alloc (struct crypto_ablkcipher * tfm,
 	gfp_t gfp);
------------
 
*Arguments*

tfm::
    cipher handle to be registered with the request 
gfp::
    memory allocation flag that is handed to kmalloc by the API call. 

*Description*

Allocate the request data structure that must be used with the ablkcipher encrypt and decrypt API calls. During the allocation, the provided ablkcipher handle is registered in the request data structure.

*Return*

allocated request handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[ablkcipher_request_free]]
*Name*

ablkcipher_request_free — zeroize and free request data structure

.Synopsis
[source,c]
------------
void ablkcipher_request_free (struct ablkcipher_request * req);
------------
 
*Arguments*

req::
    request data structure cipher handle to be freed 

<<<

[[ablkcipher_request_set_callback]]
*Name*

ablkcipher_request_set_callback — set asynchronous callback function

.Synopsis
[source,c]
------------
void ablkcipher_request_set_callback (struct ablkcipher_request * req,
 	u32 flags,
 	crypto_completion_t compl,
 	void * data);
------------
 
*Arguments*

req::
    request handle 
flags::
    specify zero or an ORing of the flags CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and increase the wait queue beyond the initial maximum size; CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep 
compl::
    callback function pointer to be registered with the request handle 
data::
    The data pointer refers to memory that is not used by the kernel crypto API, but provided to the callback function for it to use. Here, the caller can provide a reference to memory the callback function can operate on. As the callback function is invoked asynchronously to the related functionality, it may need to access data structures of the related functionality which can be referenced using this pointer. The callback function can access the memory via the “data” field in the crypto_async_request data structure provided to the callback function. 

*Description*

This function allows setting the callback function that is triggered once the cipher operation completes.

The callback function is registered with the ablkcipher_request handle and must comply with the following template

[source,c]
----------------
void callback_function(struct crypto_async_request *req, int error) 
----------------

<<<

[[ablkcipher_request_set_crypt]]
*Name*

ablkcipher_request_set_crypt — set data buffers

.Synopsis
[source,c]
------------
void ablkcipher_request_set_crypt (struct ablkcipher_request * req,
 	struct scatterlist * src,
 	struct scatterlist * dst,
 	unsigned int nbytes,
 	void * iv);
------------
 
*Arguments*

req::
    request handle 
src::
    source scatter / gather list 
dst::
    destination scatter / gather list 
nbytes::
    number of bytes to process from src 
iv::
    IV for the cipher operation which must comply with the IV size defined by crypto_ablkcipher_ivsize 

*Description*

This function allows setting of the source data and destination data scatter / gather lists.

For encryption, the source is treated as the plaintext and the destination is the ciphertext. For a decryption operation, the use is reversed - the source is the ciphertext and the destination is the plaintext. 

<<<

=== Authenticated Encryption With Associated Data (AEAD) Cipher API

<<crypto_alloc_aead, crypto_alloc_aead>> — allocate AEAD cipher handle +
<<crypto_free_aead, crypto_free_aead>> — zeroize and free aead handle +
<<crypto_aead_ivsize, crypto_aead_ivsize>> — obtain IV size +
<<crypto_aead_authsize, crypto_aead_authsize>> — obtain maximum authentication data size +
<<crypto_aead_blocksize, crypto_aead_blocksize>> — obtain block size of cipher +
<<crypto_aead_setkey, crypto_aead_setkey>> — set key for cipher +
<<crypto_aead_setauthsize, crypto_aead_setauthsize>> — set authentication data size +
<<crypto_aead_encrypt, crypto_aead_encrypt>> — encrypt plaintext +
<<crypto_aead_decrypt, crypto_aead_decrypt>> — decrypt ciphertext

The AEAD cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_AEAD (listed as type “aead” in /proc/crypto)

The most prominent examples for this type of encryption is GCM and CCM. However, the kernel supports other types of AEAD ciphers which are defined with the following cipher string:

--------
authenc(keyed message digest, block cipher)
--------

For example: authenc(hmac(sha256), cbc(aes))

The example code provided for the asynchronous block cipher operation applies here as well. Naturally all *ablkcipher* symbols must be exchanged the *aead* pendants discussed in the following. In addtion, for the AEAD operation, the aead_request_set_assoc function must be used to set the pointer to the associated data memory location before performing the encryption or decryption operation. In case of an encryption, the associated data memory is filled during the encryption operation. For decryption, the associated data memory must contain data that is used to verify the integrity of the decrypted data. Another deviation from the asynchronous block cipher operation is that the caller should explicitly check for -EBADMSG of the crypto_aead_decrypt. That error indicates an authentication error, i.e. a breach in the integrity of the message. In essence, that -EBADMSG error code is the key bonus an AEAD cipher has over “standard” block chaining modes. 

<<<

[[crypto_alloc_aead]]
*Name*

crypto_alloc_aead — allocate AEAD cipher handle

.Synopsis
[source,c]
------------
struct crypto_aead * crypto_alloc_aead (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the AEAD cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for an AEAD. The returned struct crypto_aead is the cipher handle that is required for any subsequent API invocation for that AEAD.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_aead]]
*Name*

crypto_free_aead — zeroize and free aead handle

.Synopsis
[source,c]
------------
void crypto_free_aead (struct crypto_aead * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_aead_ivsize]]
*Name*

crypto_aead_ivsize — obtain IV size

.Synopsis
[source,c]
------------
unsigned int crypto_aead_ivsize (struct crypto_aead * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The size of the IV for the aead referenced by the cipher handle is returned. This IV size may be zero if the cipher does not need an IV.

*Return*

IV size in bytes 

<<<

[[crypto_aead_authsize]]
*Name*

crypto_aead_authsize — obtain maximum authentication data size

.Synopsis
[source,c]
------------
unsigned int crypto_aead_authsize (struct crypto_aead * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The maximum size of the authentication data for the AEAD cipher referenced by the AEAD cipher handle is returned. The authentication data size may be zero if the cipher implements a hard-coded maximum.

The authentication data may also be known as “tag value”.

*Return*

authentication data size / tag size in bytes 

<<<

[[crypto_aead_blocksize]]
*Name*

crypto_aead_blocksize — obtain block size of cipher

.Synopsis
[source,c]
------------
unsigned int crypto_aead_blocksize (struct crypto_aead * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The block size for the AEAD referenced with the cipher handle is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation

*Return*

block size of cipher 

<<<

[[crypto_aead_setkey]]
*Name*

crypto_aead_setkey — set key for cipher
.Synopsis
[source,c]
------------
int crypto_aead_setkey (struct crypto_aead * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

tfm::
    cipher handle 
key::
    buffer holding the key 
keylen::
    length of the key in bytes 

*Description*

The caller provided key is set for the AEAD referenced by the cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_aead_setauthsize]]
*Name*

crypto_aead_setauthsize — set authentication data size

.Synopsis
[source,c]
------------
int crypto_aead_setauthsize (struct crypto_aead * tfm,
 	unsigned int authsize);
------------
 
*Arguments*

tfm::
    cipher handle 
authsize::
    size of the authentication data / tag in bytes 

*Description*

Set the authentication data size / tag size. AEAD requires an authentication tag (or MAC) in addition to the associated data.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_aead_encrypt]]
*Name*

crypto_aead_encrypt — encrypt plaintext

.Synopsis
[source,c]
------------
int crypto_aead_encrypt (struct aead_request * req);
------------
 
*Arguments*

req::
    reference to the aead_request handle that holds all information needed to perform the cipher operation 

*Description*

Encrypt plaintext data using the aead_request handle. That data structure and how it is filled with data is discussed with the aead_request_* functions.

[IMPORTANT]
The encryption operation creates the authentication data / tag. That data is concatenated with the created ciphertext. The ciphertext memory size is therefore the given number of block cipher blocks + the size defined by the crypto_aead_setauthsize invocation. The caller must ensure that sufficient memory is available for the ciphertext and the authentication tag.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_aead_decrypt]]
*Name*

crypto_aead_decrypt — decrypt ciphertext
.Synopsis
[source,c]
------------
int crypto_aead_decrypt (struct aead_request * req);
------------
 
*Arguments*

req::
    reference to the ablkcipher_request handle that holds all information needed to perform the cipher operation 

*Description*

Decrypt ciphertext data using the aead_request handle. That data structure and how it is filled with data is discussed with the aead_request_* functions.

[IMPORTANT]
The caller must concatenate the ciphertext followed by the authentication data / tag. That authentication data / tag must have the size defined by the crypto_aead_setauthsize invocation.

*Return*

0 if the cipher operation was successful; -EBADMSG: The AEAD cipher operation performs the authentication of the data during the decryption operation. Therefore, the function returns this error if the authentication of the ciphertext was unsuccessful (i.e. the integrity of the ciphertext or the associated data was violated); < 0 if an error occurred. 

<<<

=== Asynchronous AEAD Request Handle

<<crypto_aead_reqsize, crypto_aead_reqsize>> — obtain size of the request data structure +
<<aead_request_set_tfm, aead_request_set_tfm>> — update cipher handle reference in request +
<<aead_request_alloc, aead_request_alloc>> — allocate request data structure +
<<aead_request_free, aead_request_free>> — zeroize and free request data structure +
<<aead_request_set_callback, aead_request_set_callback>> — set asynchronous callback function +
<<aead_request_set_crypt, aead_request_set_crypt>> — set data buffers +
<<aead_request_set_assoc, aead_request_set_assoc>> — set the associated data scatter / gather list

The aead_request data structure contains all pointers to data required for the AEAD cipher operation. This includes the cipher handle (which can be used by multiple aead_request instances), pointer to plaintext and ciphertext, asynchronous callback function, etc. It acts as a handle to the aead_request_* API calls in a similar way as AEAD handle to the crypto_aead_* API calls. 

<<<

[[crypto_aead_reqsize]]
*Name*

crypto_aead_reqsize — obtain size of the request data structure

.Synopsis
[source,c]
------------
unsigned int crypto_aead_reqsize (struct crypto_aead * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Return*

number of bytes 

<<<

[[aead_request_set_tfm]]
*Name*

aead_request_set_tfm — update cipher handle reference in request

.Synopsis
[source,c]
------------
void aead_request_set_tfm (struct aead_request * req,
 	struct crypto_aead * tfm);
------------
 
*Arguments*

req::
    request handle to be modified 
tfm::
    cipher handle that shall be added to the request handle 

*Description*

Allow the caller to replace the existing aead handle in the request data structure with a different one. 

<<<

[[aead_request_alloc]]
*Name*

aead_request_alloc — allocate request data structure

.Synopsis
[source,c]
------------
struct aead_request * aead_request_alloc (struct crypto_aead * tfm,
 	gfp_t gfp);
------------
 
*Arguments*

tfm::
    cipher handle to be registered with the request 
gfp::
    memory allocation flag that is handed to kmalloc by the API call. 

*Description*

Allocate the request data structure that must be used with the AEAD encrypt and decrypt API calls. During the allocation, the provided aead handle is registered in the request data structure.

*Return*

allocated request handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[aead_request_free]]
*Name*

aead_request_free — zeroize and free request data structure

.Synopsis
[source,c]
------------
void aead_request_free (struct aead_request * req);
------------
 
*Arguments*

req::
    request data structure cipher handle to be freed 

<<<

[[aead_request_set_callback]]
*Name*

aead_request_set_callback — set asynchronous callback function

.Synopsis
[source,c]
------------
void aead_request_set_callback (struct aead_request * req,
 	u32 flags,
 	crypto_completion_t compl,
 	void * data);
------------
 
*Arguments*

req::
    request handle 
flags::
    specify zero or an ORing of the flags CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and increase the wait queue beyond the initial maximum size; CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep 
compl::
    callback function pointer to be registered with the request handle 
data::
    The data pointer refers to memory that is not used by the kernel crypto API, but provided to the callback function for it to use. Here, the caller can provide a reference to memory the callback function can operate on. As the callback function is invoked asynchronously to the related functionality, it may need to access data structures of the related functionality which can be referenced using this pointer. The callback function can access the memory via the “data” field in the crypto_async_request data structure provided to the callback function. 

*Description*

Setting the callback function that is triggered once the cipher operation completes

The callback function is registered with the aead_request handle and must comply with the following template

[source,c]
-----------------------
void callback_function(struct crypto_async_request *req, int error) 
-----------------------

<<<

[[aead_request_set_crypt]]
*Name*

aead_request_set_crypt — set data buffers

.Synopsis
[source,c]
------------
void aead_request_set_crypt (struct aead_request * req,
 	struct scatterlist * src,
 	struct scatterlist * dst,
 	unsigned int cryptlen,
 	u8 * iv);
------------
 
*Arguments*

req::
    request handle 
src::
    source scatter / gather list 
dst::
    destination scatter / gather list 
cryptlen::
    number of bytes to process from src 
iv::
    IV for the cipher operation which must comply with the IV size defined by crypto_aead_ivsize 

*Description*

Setting the source data and destination data scatter / gather lists.

For encryption, the source is treated as the plaintext and the destination is the ciphertext. For a decryption operation, the use is reversed - the source is the ciphertext and the destination is the plaintext.

[IMPORTANT]
requires an authentication tag (MAC). For decryption, the caller must concatenate the ciphertext followed by the authentication tag and provide the entire data stream to the decryption operation (i.e. the data length used for the initialization of the scatterlist and the data length for the decryption operation is identical). For encryption, however, the authentication tag is created while encrypting the data. The destination buffer must hold sufficient space for the ciphertext and the authentication tag while the encryption invocation must only point to the plaintext data size. The following code snippet illustrates the memory usage.

[source,c]
----------------------
buffer = kmalloc(ptbuflen + (enc ? authsize : 0));
sg_init_one(sg, buffer, ptbuflen + (enc ? authsize : 0));
aead_request_set_crypt(req, sg, sg, ptbuflen, iv); 
----------------------

<<<

[[aead_request_set_assoc]]
*Name*

aead_request_set_assoc — set the associated data scatter / gather list

.Synopsis
[source,c]
------------
void aead_request_set_assoc (struct aead_request * req,
 	struct scatterlist * assoc,
 	unsigned int assoclen);
------------
 
*Arguments*

req::
    request handle 
assoc::
    associated data scatter / gather list 
assoclen::
    number of bytes to process from assoc 

*Description*

For encryption, the memory is filled with the associated data. For decryption, the memory must point to the associated data. 

<<<

=== Synchronous Block Cipher API

<<crypto_alloc_blkcipher, crypto_alloc_blkcipher>> — allocate synchronous block cipher handle +
<<crypto_free_blkcipher, crypto_free_blkcipher>> — zeroize and free the block cipher handle +
<<crypto_has_blkcipher, crypto_has_blkcipher>> — Search for the availability of a block cipher +
<<crypto_blkcipher_name, crypto_blkcipher_name>> — return the name / cra_name from the cipher handle +
<<crypto_blkcipher_ivsize, crypto_blkcipher_ivsize>> — obtain IV size +
<<crypto_blkcipher_blocksize, crypto_blkcipher_blocksize>> — obtain block size of cipher +
<<crypto_blkcipher_setkey, crypto_blkcipher_setkey>> — set key for cipher +
<<crypto_blkcipher_encrypt, crypto_blkcipher_encrypt>> — encrypt plaintext +
<<crypto_blkcipher_encrypt_iv, crypto_blkcipher_encrypt_iv>> — encrypt plaintext with dedicated IV +
<<crypto_blkcipher_decrypt, crypto_blkcipher_decrypt>> — decrypt ciphertext +
<<crypto_blkcipher_decrypt_iv, crypto_blkcipher_decrypt_iv>> — decrypt ciphertext with dedicated IV +
<<crypto_blkcipher_set_iv, crypto_blkcipher_set_iv>> — set IV for cipher +
<<crypto_blkcipher_get_iv, crypto_blkcipher_get_iv>> — obtain IV from cipher

The synchronous block cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_BLKCIPHER (listed as type “blkcipher” in /proc/crypto)

Synchronous calls, have a context in the tfm. But since a single tfm can be used in multiple calls and in parallel, this info should not be changeable (unless a lock is used). This applies, for example, to the symmetric key. However, the IV is changeable, so there is an iv field in blkcipher_tfm structure for synchronous blkcipher api. So, its the only state info that can be kept for synchronous calls without using a big lock across a tfm.

The block cipher API allows the use of a complete cipher, i.e. a cipher consisting of a template (a block chaining mode) and a single block cipher primitive (e.g. AES).

The plaintext data buffer and the ciphertext data buffer are pointed to by using scatter/gather lists. The cipher operation is performed on all segments of the provided scatter/gather lists.

The kernel crypto API supports a cipher operation “in-place” which means that the caller may provide the same scatter/gather list for the plaintext and cipher text. After the completion of the cipher operation, the plaintext data is replaced with the ciphertext data in case of an encryption and vice versa for a decryption. The caller must ensure that the scatter/gather lists for the output data point to sufficiently large buffers, i.e. multiples of the block size of the cipher. 

<<<

[[crypto_alloc_blkcipher]]
*Name*

crypto_alloc_blkcipher — allocate synchronous block cipher handle

.Synopsis
[source,c]
------------
struct crypto_blkcipher * crypto_alloc_blkcipher (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the blkcipher cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for a block cipher. The returned struct crypto_blkcipher is the cipher handle that is required for any subsequent API invocation for that block cipher.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_blkcipher]]
*Name*

crypto_free_blkcipher — zeroize and free the block cipher handle

.Synopsis
[source,c]
------------
void crypto_free_blkcipher (struct crypto_blkcipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_has_blkcipher]]
*Name*

crypto_has_blkcipher — Search for the availability of a block cipher

.Synopsis
[source,c]
------------
int crypto_has_blkcipher (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the block cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Return*

true when the block cipher is known to the kernel crypto API; false otherwise 

<<<

[[crypto_blkcipher_name]]
*Name*

crypto_blkcipher_name — return the name / cra_name from the cipher handle

.Synopsis
[source,c]
------------
const char * crypto_blkcipher_name (struct crypto_blkcipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Return*

The character string holding the name of the cipher 

<<<

[[crypto_blkcipher_ivsize]]
*Name*

crypto_blkcipher_ivsize — obtain IV size

.Synopsis
[source,c]
------------
unsigned int crypto_blkcipher_ivsize (struct crypto_blkcipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The size of the IV for the block cipher referenced by the cipher handle is returned. This IV size may be zero if the cipher does not need an IV.

*Return*

IV size in bytes 

<<<

[[crypto_blkcipher_blocksize]]
*Name*

crypto_blkcipher_blocksize — obtain block size of cipher

.Synopsis
[source,c]
------------
unsigned int crypto_blkcipher_blocksize (struct crypto_blkcipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The block size for the block cipher referenced with the cipher handle is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation.

*Return*

block size of cipher 

<<<

[[crypto_blkcipher_setkey]]
*Name*

crypto_blkcipher_setkey — set key for cipher

.Synopsis
[source,c]
------------
int crypto_blkcipher_setkey (struct crypto_blkcipher * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

tfm::
    cipher handle 
key::
    buffer holding the key 
keylen::
    length of the key in bytes 

*Description*

The caller provided key is set for the block cipher referenced by the cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_blkcipher_encrypt]]
*Name*

crypto_blkcipher_encrypt — encrypt plaintext

.Synopsis
[source,c]
------------
int crypto_blkcipher_encrypt (struct blkcipher_desc * desc,
 	struct scatterlist * dst,
 	struct scatterlist * src,
 	unsigned int nbytes);
------------
 
*Arguments*

desc::
    reference to the block cipher handle with meta data 
dst::
    scatter/gather list that is filled by the cipher operation with the ciphertext 
src::
    scatter/gather list that holds the plaintext 
nbytes::
    number of bytes of the plaintext to encrypt. 

*Description*

Encrypt plaintext data using the IV set by the caller with a preceding call of crypto_blkcipher_set_iv.

The blkcipher_desc data structure must be filled by the caller and can reside on the stack. The caller must fill desc as follows: desc.tfm is filled with the block cipher handle; desc.flags is filled with either CRYPTO_TFM_REQ_MAY_SLEEP or 0.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_blkcipher_encrypt_iv]]
*Name*

crypto_blkcipher_encrypt_iv — encrypt plaintext with dedicated IV

.Synopsis
[source,c]
------------
int crypto_blkcipher_encrypt_iv (struct blkcipher_desc * desc,
 	struct scatterlist * dst,
 	struct scatterlist * src,
 	unsigned int nbytes);
------------
 
*Arguments*

desc::
    reference to the block cipher handle with meta data 
dst::
    scatter/gather list that is filled by the cipher operation with the ciphertext 
src::
    scatter/gather list that holds the plaintext 
nbytes::
    number of bytes of the plaintext to encrypt. 

*Description*

Encrypt plaintext data with the use of an IV that is solely used for this cipher operation. Any previously set IV is not used.

The blkcipher_desc data structure must be filled by the caller and can reside on the stack. The caller must fill desc as follows: desc.tfm is filled with the block cipher handle; desc.info is filled with the IV to be used for the current operation; desc.flags is filled with either CRYPTO_TFM_REQ_MAY_SLEEP or 0.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_blkcipher_decrypt]]
*Name*

crypto_blkcipher_decrypt — decrypt ciphertext
.Synopsis
[source,c]
------------
int crypto_blkcipher_decrypt (struct blkcipher_desc * desc,
 	struct scatterlist * dst,
 	struct scatterlist * src,
 	unsigned int nbytes);
------------
 
*Arguments*

desc::
    reference to the block cipher handle with meta data 
dst::
    scatter/gather list that is filled by the cipher operation with the plaintext 
src::
    scatter/gather list that holds the ciphertext 
nbytes::
    number of bytes of the ciphertext to decrypt. 

*Description*

Decrypt ciphertext data using the IV set by the caller with a preceding call of crypto_blkcipher_set_iv.

The blkcipher_desc data structure must be filled by the caller as documented for the crypto_blkcipher_encrypt call above.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_blkcipher_decrypt_iv]]
*Name*

crypto_blkcipher_decrypt_iv — decrypt ciphertext with dedicated IV

.Synopsis
[source,c]
------------
int crypto_blkcipher_decrypt_iv (struct blkcipher_desc * desc,
 	struct scatterlist * dst,
 	struct scatterlist * src,
 	unsigned int nbytes);
------------
 
*Arguments*

desc::
    reference to the block cipher handle with meta data 
dst::
    scatter/gather list that is filled by the cipher operation with the plaintext 
src::
    scatter/gather list that holds the ciphertext 
nbytes::
    number of bytes of the ciphertext to decrypt. 

*Description*

Decrypt ciphertext data with the use of an IV that is solely used for this cipher operation. Any previously set IV is not used.

The blkcipher_desc data structure must be filled by the caller as documented for the crypto_blkcipher_encrypt_iv call above.

*Return*

0 if the cipher operation was successful; < 0 if an error occurred 

<<<

[[crypto_blkcipher_set_iv]]
*Name*

crypto_blkcipher_set_iv — set IV for cipher

.Synopsis
[source,c]
------------
void crypto_blkcipher_set_iv (struct crypto_blkcipher * tfm,
 	const u8 * src,
 	unsigned int len);
------------
 
*Arguments*

tfm::
    cipher handle 
src::
    buffer holding the IV 
len::
    length of the IV in bytes 

*Description*

The caller provided IV is set for the block cipher referenced by the cipher handle. 

<<<

[[crypto_blkcipher_get_iv]]
*Name*

crypto_blkcipher_get_iv — obtain IV from cipher

.Synopsis
[source,c]
------------
void crypto_blkcipher_get_iv (struct crypto_blkcipher * tfm,
 	u8 * dst,
 	unsigned int len);
------------
 
*Arguments*

tfm::
    cipher handle 
dst::
    buffer filled with the IV 
len::
    length of the buffer dst 

*Description*

The caller can obtain the IV set for the block cipher referenced by the cipher handle and store it into the user-provided buffer. If the buffer has an insufficient space, the IV is truncated to fit the buffer. 

<<<

=== Single Block Cipher API

<<crypto_alloc_cipher, crypto_alloc_cipher>> — allocate single block cipher handle +
<<crypto_free_cipher, crypto_free_cipher>> — zeroize and free the single block cipher handle +
<<crypto_has_cipher, crypto_has_cipher>> — Search for the availability of a single block cipher +
<<crypto_cipher_blocksize, crypto_cipher_blocksize>> — obtain block size for cipher +
<<crypto_cipher_setkey, crypto_cipher_setkey>> — set key for cipher +
<<crypto_cipher_encrypt_one, crypto_cipher_encrypt_one>> — encrypt one block of plaintext +
<<crypto_cipher_decrypt_one, crypto_cipher_decrypt_one>> — decrypt one block of ciphertext

The single block cipher API is used with the ciphers of type CRYPTO_ALG_TYPE_CIPHER (listed as type “cipher” in /proc/crypto).

Using the single block cipher API calls, operations with the basic cipher primitive can be implemented. These cipher primitives exclude any block chaining operations including IV handling.

The purpose of this single block cipher API is to support the implementation of templates or other concepts that only need to perform the cipher operation on one block at a time. Templates invoke the underlying cipher primitive block-wise and process either the input or the output data of these cipher operations. 

<<<

[[crypto_alloc_cipher]]
*Name*

crypto_alloc_cipher — allocate single block cipher handle

.Synopsis
[source,c]
------------
struct crypto_cipher * crypto_alloc_cipher (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the single block cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for a single block cipher. The returned struct crypto_cipher is the cipher handle that is required for any subsequent API invocation for that single block cipher.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_cipher]]
*Name*

crypto_free_cipher — zeroize and free the single block cipher handle

.Synopsis
[source,c]
------------
void crypto_free_cipher (struct crypto_cipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_has_cipher]]
*Name*

crypto_has_cipher — Search for the availability of a single block cipher

.Synopsis
[source,c]
------------
int crypto_has_cipher (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the single block cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Return*

true when the single block cipher is known to the kernel crypto API; false otherwise 

<<<

[[crypto_cipher_blocksize]]
*Name*

crypto_cipher_blocksize — obtain block size for cipher

.Synopsis
[source,c]
------------
unsigned int crypto_cipher_blocksize (struct crypto_cipher * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The block size for the single block cipher referenced with the cipher handle tfm is returned. The caller may use that information to allocate appropriate memory for the data returned by the encryption or decryption operation

*Return*

block size of cipher 

<<<

[[crypto_cipher_setkey]]
*Name*

crypto_cipher_setkey — set key for cipher

.Synopsis
[source,c]
------------
int crypto_cipher_setkey (struct crypto_cipher * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

tfm::
    cipher handle 
key::
    buffer holding the key 
keylen::
    length of the key in bytes 

*Description*

The caller provided key is set for the single block cipher referenced by the cipher handle.

Note, the key length determines the cipher type. Many block ciphers implement different cipher modes depending on the key size, such as AES-128 vs AES-192 vs. AES-256. When providing a 16 byte key for an AES cipher handle, AES-128 is performed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_cipher_encrypt_one]]
*Name*

crypto_cipher_encrypt_one — encrypt one block of plaintext

.Synopsis
[source,c]
------------
void crypto_cipher_encrypt_one (struct crypto_cipher * tfm,
 	u8 * dst,
 	const u8 * src);
------------
 
*Arguments*

tfm::
    cipher handle 
dst::
    points to the buffer that will be filled with the ciphertext 
src::
    buffer holding the plaintext to be encrypted 

*Description*

Invoke the encryption operation of one block. The caller must ensure that the plaintext and ciphertext buffers are at least one block in size. 

<<<

[[crypto_cipher_decrypt_one]]
*Name*

crypto_cipher_decrypt_one — decrypt one block of ciphertext

.Synopsis
[source,c]
------------
void crypto_cipher_decrypt_one (struct crypto_cipher * tfm,
 	u8 * dst,
 	const u8 * src);
------------
 
*Arguments*

tfm::
    cipher handle 
dst::
    points to the buffer that will be filled with the plaintext 
src::
    buffer holding the ciphertext to be decrypted 

*Description*

Invoke the decryption operation of one block. The caller must ensure that the plaintext and ciphertext buffers are at least one block in size. 

<<<

=== Synchronous Message Digest API

<<crypto_alloc_hash, crypto_alloc_hash>> — allocate synchronous message digest handle +
<<crypto_free_hash, crypto_free_hash>> — zeroize and free message digest handle +
<<crypto_has_hash, crypto_has_hash>> — Search for the availability of a message digest +
<<crypto_hash_blocksize, crypto_hash_blocksize>> — obtain block size for message digest +
<<crypto_hash_digestsize, crypto_hash_digestsize>> — obtain message digest size +
<<crypto_hash_init, crypto_hash_init>> — (re)initialize message digest handle +
<<crypto_hash_update, crypto_hash_update>> — add data to message digest for processing +
<<crypto_hash_final, crypto_hash_final>> — calculate message digest +
<<crypto_hash_digest, crypto_hash_digest>> — calculate message digest for a buffer +
<<crypto_hash_setkey, crypto_hash_setkey>> — set key for message digest

The synchronous message digest API is used with the ciphers of type CRYPTO_ALG_TYPE_HASH (listed as type “hash” in /proc/crypto) 

<<<

[[crypto_alloc_hash]]
*Name*

crypto_alloc_hash — allocate synchronous message digest handle

.Synopsis
[source,c]
------------
struct crypto_hash * crypto_alloc_hash (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the message digest cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for a message digest. The returned struct crypto_hash is the cipher handle that is required for any subsequent API invocation for that message digest.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_hash]]
*Name*

crypto_free_hash — zeroize and free message digest handle

.Synopsis
[source,c]
------------
void crypto_free_hash (struct crypto_hash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_has_hash]]
*Name*

crypto_has_hash — Search for the availability of a message digest

.Synopsis
[source,c]
------------
int crypto_has_hash (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the message digest cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Return*

true when the message digest cipher is known to the kernel crypto API; false otherwise 

<<<

[[crypto_hash_blocksize]]
*Name*

crypto_hash_blocksize — obtain block size for message digest

.Synopsis
[source,c]
------------
unsigned int crypto_hash_blocksize (struct crypto_hash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The block size for the message digest cipher referenced with the cipher handle is returned.

*Return*

block size of cipher 

<<<

[[crypto_hash_digestsize]]
*Name*

crypto_hash_digestsize — obtain message digest size

.Synopsis
[source,c]
------------
unsigned int crypto_hash_digestsize (struct crypto_hash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The size for the message digest created by the message digest cipher referenced with the cipher handle is returned.

*Return*

message digest size 

<<<

[[crypto_hash_init]]
*Name*

crypto_hash_init — (re)initialize message digest handle

.Synopsis
[source,c]
------------
int crypto_hash_init (struct hash_desc * desc);
------------
 
*Arguments*

desc::
    cipher request handle that to be filled by caller -- desc.tfm is filled with the hash cipher handle; desc.flags is filled with either CRYPTO_TFM_REQ_MAY_SLEEP or 0. 

*Description*

The call (re-)initializes the message digest referenced by the hash cipher request handle. Any potentially existing state created by previous operations is discarded.

*Return*

0 if the message digest initialization was successful; < 0 if an error occurred 

<<<

[[crypto_hash_update]]
*Name*

crypto_hash_update — add data to message digest for processing

.Synopsis
[source,c]
------------
int crypto_hash_update (struct hash_desc * desc,
 	struct scatterlist * sg,
 	unsigned int nbytes);
------------
 
*Arguments*

desc::
    cipher request handle 
sg::
    scatter / gather list pointing to the data to be added to the message digest 
nbytes::
    number of bytes to be processed from sg 

*Description*

Updates the message digest state of the cipher handle pointed to by the hash cipher request handle with the input data pointed to by the scatter/gather list.

*Return*

0 if the message digest update was successful; < 0 if an error occurred 

<<<

[[crypto_hash_final]]
*Name*

crypto_hash_final — calculate message digest

.Synopsis
[source,c]
------------
int crypto_hash_final (struct hash_desc * desc,
 	u8 * out);
------------
 
*Arguments*

desc::
    cipher request handle 
out::
    message digest output buffer -- The caller must ensure that the out buffer has a sufficient size (e.g. by using the crypto_hash_digestsize function). 

*Description*

Finalize the message digest operation and create the message digest based on all data added to the cipher handle. The message digest is placed into the output buffer.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_hash_digest]]
*Name*

crypto_hash_digest — calculate message digest for a buffer

.Synopsis
[source,c]
------------
int crypto_hash_digest (struct hash_desc * desc,
 	struct scatterlist * sg,
 	unsigned int nbytes,
 	u8 * out);
------------
 
*Arguments*

desc::
    see crypto_hash_final 
sg::
    see crypto_hash_update 
nbytes::
    see crypto_hash_update 
out::
    see crypto_hash_final 

*Description*

This function is a “short-hand” for the function calls of crypto_hash_init, crypto_hash_update and crypto_hash_final. The parameters have the same meaning as discussed for those separate three functions.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_hash_setkey]]
*Name*

crypto_hash_setkey — set key for message digest

.Synopsis
[source,c]
------------
int crypto_hash_setkey (struct crypto_hash * hash,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

hash::
    cipher handle 
key::
    buffer holding the key 
keylen::
    length of the key in bytes 

*Description*

The caller provided key is set for the message digest cipher. The cipher handle must point to a keyed hash in order for this function to succeed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

=== Message Digest Algorithm Definitions

<<hash_alg_common, struct hash_alg_common>> — define properties of message digest +
<<ahash_alg, struct ahash_alg>> — asynchronous message digest definition +
<<shash_alg, struct shash_alg>> — synchronous message digest definition 

These data structures define modular message digest algorithm implementations, managed via crypto_register_ahash, crypto_register_shash, crypto_unregister_ahash and crypto_unregister_shash. 

<<<

[[hash_alg_common]]
*Name*

struct hash_alg_common — define properties of message digest

.Synopsis
[source,c]
------------
struct hash_alg_common {
  unsigned int digestsize;
  unsigned int statesize;
  struct crypto_alg base;
};  
------------

Members

digestsize::
    Size of the result of the transformation. A buffer of this size must be available to the final and finup calls, so they can store the resulting hash into it. For various predefined sizes, search include/crypto/ using git grep _DIGEST_SIZE include/crypto. 
statesize::
    Size of the block for partial state of the transformation. A buffer of this size must be passed to the export function as it will save the partial state of the transformation into it. On the other side, the import function will load the state from a buffer of this size as well. 
base::
    Start of data structure of cipher algorithm. The common data structure of crypto_alg contains information common to all ciphers. The hash_alg_common data structure now adds the hash-specific information. 

<<<

[[ahash_alg]]
*Name*

struct ahash_alg — asynchronous message digest definition

.Synopsis
[source,c]
------------
struct ahash_alg {
  int (* init) (struct ahash_request *req);
  int (* update) (struct ahash_request *req);
  int (* final) (struct ahash_request *req);
  int (* finup) (struct ahash_request *req);
  int (* digest) (struct ahash_request *req);
  int (* export) (struct ahash_request *req, void *out);
  int (* import) (struct ahash_request *req, const void *in);
  int (* setkey) (struct crypto_ahash *tfm, const u8 *key,unsigned int keylen);
  struct hash_alg_common halg;
};  
------------

Members

init::
    Initialize the transformation context. Intended only to initialize the state of the HASH transformation at the begining. This shall fill in the internal structures used during the entire duration of the whole transformation. No data processing happens at this point. 
update::
    Push a chunk of data into the driver for transformation. This function actually pushes blocks of data from upper layers into the driver, which then passes those to the hardware as seen fit. This function must not finalize the HASH transformation by calculating the final message digest as this only adds more data into the transformation. This function shall not modify the transformation context, as this function may be called in parallel with the same transformation object. Data processing can happen synchronously [SHASH] or asynchronously [AHASH] at this point. 
final::
    Retrieve result from the driver. This function finalizes the transformation and retrieves the resulting hash from the driver and pushes it back to upper layers. No data processing happens at this point. 
finup::
    Combination of update and final. This function is effectively a combination of update and final calls issued in sequence. As some hardware cannot do update and final separately, this callback was added to allow such hardware to be used at least by IPsec. Data processing can happen synchronously [SHASH] or asynchronously [AHASH] at this point. 
digest::
    Combination of init and update and final. This function effectively behaves as the entire chain of operations, init, update and final issued in sequence. Just like finup, this was added for hardware which cannot do even the finup, but can only do the whole transformation in one run. Data processing can happen synchronously [SHASH] or asynchronously [AHASH] at this point. 
export::
    Export partial state of the transformation. This function dumps the entire state of the ongoing transformation into a provided block of data so it can be import 'ed back later on. This is useful in case you want to save partial result of the transformation after processing certain amount of data and reload this partial result multiple times later on for multiple re-use. No data processing happens at this point. 
import::
    Import partial state of the transformation. This function loads the entire state of the ongoing transformation from a provided block of data so the transformation can continue from this point onward. No data processing happens at this point. 
setkey::
    Set optional key used by the hashing algorithm. Intended to push optional key used by the hashing algorithm from upper layers into the driver. This function can store the key in the transformation context or can outright program it into the hardware. In the former case, one must be careful to program the key into the hardware at appropriate time and one must be careful that .setkey can be called multiple times during the existence of the transformation object. Not all hashing algorithms do implement this function as it is only needed for keyed message digests. SHAx/MDx/CRCx do NOT implement this function. HMAC(MDx)/HMAC(SHAx)/CMAC(AES) do implement this function. This function must be called before any other of the init, update, final, finup, digest is called. No data processing happens at this point. 
halg::
    see struct hash_alg_common 

<<<

[[shash_alg]]
*Name*

struct shash_alg — synchronous message digest definition

.Synopsis
[source,c]
------------
struct shash_alg {
  int (* init) (struct shash_desc *desc);
  int (* update) (struct shash_desc *desc, const u8 *data,unsigned int len);
  int (* final) (struct shash_desc *desc, u8 *out);
  int (* finup) (struct shash_desc *desc, const u8 *data,unsigned int len, u8 *out);
  int (* digest) (struct shash_desc *desc, const u8 *data,unsigned int len, u8 *out);
  int (* export) (struct shash_desc *desc, void *out);
  int (* import) (struct shash_desc *desc, const void *in);
  int (* setkey) (struct crypto_shash *tfm, const u8 *key,unsigned int keylen);
  unsigned int descsize;
  unsigned int statesize;
  struct crypto_alg base;
};  
------------

Members

init::
    see struct ahash_alg 
update::
    see struct ahash_alg 
final::
    see struct ahash_alg 
finup::
    see struct ahash_alg 
digest::
    see struct ahash_alg 
export::
    see struct ahash_alg 
import::
    see struct ahash_alg 
setkey::
    see struct ahash_alg 
descsize::
    Size of the operational state for the message digest. This state size is the memory size that needs to be allocated for shash_desc.__ctx 
statesize::
    see struct ahash_alg 
base::
    internally used 

<<<

=== Asynchronous Message Digest API

<<crypto_alloc_ahash, crypto_alloc_ahash>> — allocate ahash cipher handle +
<<crypto_free_ahash, crypto_free_ahash>> — zeroize and free the ahash handle +
<<crypto_ahash_init, crypto_ahash_init>> — (re)initialize message digest handle +
<<crypto_ahash_digestsize, crypto_ahash_digestsize>> — obtain message digest size +
<<crypto_ahash_reqtfm, crypto_ahash_reqtfm>> — obtain cipher handle from request +
<<crypto_ahash_reqsize, crypto_ahash_reqsize>> — obtain size of the request data structure +
<<crypto_ahash_setkey, crypto_ahash_setkey>> — set key for cipher handle +
<<crypto_ahash_finup, crypto_ahash_finup>> — update and finalize message digest +
<<crypto_ahash_final, crypto_ahash_final>> — calculate message digest +
<<crypto_ahash_digest, crypto_ahash_digest>> — calculate message digest for a buffer +
<<crypto_ahash_export, crypto_ahash_export>> — extract current message digest state +
<<crypto_ahash_import, crypto_ahash_import>> — import message digest state

The asynchronous message digest API is used with the ciphers of type CRYPTO_ALG_TYPE_AHASH (listed as type “ahash” in /proc/crypto)

The asynchronous cipher operation discussion provided for the CRYPTO_ALG_TYPE_ABLKCIPHER API applies here as well. 

[[crypto_alloc_ahash]]
*Name*

crypto_alloc_ahash — allocate ahash cipher handle

.Synopsis
[source,c]
------------
struct crypto_ahash * crypto_alloc_ahash (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the ahash cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for an ahash. The returned struct crypto_ahash is the cipher handle that is required for any subsequent API invocation for that ahash.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_ahash]]
*Name*

crypto_free_ahash — zeroize and free the ahash handle

.Synopsis
[source,c]
------------
void crypto_free_ahash (struct crypto_ahash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_ahash_init]]
*Name*

crypto_ahash_init — (re)initialize message digest handle

.Synopsis
[source,c]
------------
int crypto_ahash_init (struct ahash_request * req);
------------
 
*Arguments*

req::
    ahash_request handle that already is initialized with all necessary data using the ahash_request_* API functions 

*Description*

The call (re-)initializes the message digest referenced by the ahash_request handle. Any potentially existing state created by previous operations is discarded.

*Return*

0 if the message digest initialization was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_digestsize]]
*Name*

crypto_ahash_digestsize — obtain message digest size

.Synopsis
[source,c]
------------
unsigned int crypto_ahash_digestsize (struct crypto_ahash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The size for the message digest created by the message digest cipher referenced with the cipher handle is returned.

*Return*

message digest size of cipher 

<<<

*Name*

crypto_ahash_reqtfm — obtain cipher handle from request

.Synopsis
[source,c]
------------
struct crypto_ahash * crypto_ahash_reqtfm (struct ahash_request * req);
------------
 
*Arguments*

req::
    asynchronous request handle that contains the reference to the ahash cipher handle 

*Description*

Return the ahash cipher handle that is registered with the asynchronous request handle ahash_request.

*Return*

ahash cipher handle 

<<<

[[crypto_ahash_reqsize]]
*Name*

crypto_ahash_reqsize — obtain size of the request data structure

.Synopsis
[source,c]
------------
unsigned int crypto_ahash_reqsize (struct crypto_ahash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

Return the size of the ahash state size. With the crypto_ahash_export function, the caller can export the state into a buffer whose size is defined with this function.

*Return*

size of the ahash state 

<<<

[[crypto_ahash_setkey]]
*Name*

crypto_ahash_setkey — set key for cipher handle

.Synopsis
[source,c]
------------
int crypto_ahash_setkey (struct crypto_ahash * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

tfm::
    cipher handle 
key::
    buffer holding the key 
keylen::
    length of the key in bytes 

*Description*

The caller provided key is set for the ahash cipher. The cipher handle must point to a keyed hash in order for this function to succeed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_finup]]
*Name*

crypto_ahash_finup — update and finalize message digest

.Synopsis
[source,c]
------------
int crypto_ahash_finup (struct ahash_request * req);
------------
 
*Arguments*

req::
    reference to the ahash_request handle that holds all information needed to perform the cipher operation 

*Description*

This function is a “short-hand” for the function calls of crypto_ahash_update and crypto_shash_final. The parameters have the same meaning as discussed for those separate functions.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_final]]
*Name*

crypto_ahash_final — calculate message digest

.Synopsis
[source,c]
------------
int crypto_ahash_final (struct ahash_request * req);
------------
 
*Arguments*

req::
    reference to the ahash_request handle that holds all information needed to perform the cipher operation 

*Description*

Finalize the message digest operation and create the message digest based on all data added to the cipher handle. The message digest is placed into the output buffer registered with the ahash_request handle.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_digest]]
*Name*

crypto_ahash_digest — calculate message digest for a buffer

.Synopsis
[source,c]
------------
int crypto_ahash_digest (struct ahash_request * req);
------------
 
*Arguments*

req::
    reference to the ahash_request handle that holds all information needed to perform the cipher operation 

*Description*

This function is a “short-hand” for the function calls of crypto_ahash_init, crypto_ahash_update and crypto_ahash_final. The parameters have the same meaning as discussed for those separate three functions.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_export]]
*Name*

crypto_ahash_export — extract current message digest state

.Synopsis
[source,c]
------------
int crypto_ahash_export (struct ahash_request * req,
 	void * out);
------------
 
*Arguments*

req::
    reference to the ahash_request handle whose state is exported 
out::
    output buffer of sufficient size that can hold the hash state 

*Description*

This function exports the hash state of the ahash_request handle into the caller-allocated output buffer out which must have sufficient size (e.g. by calling crypto_ahash_reqsize).

*Return*

0 if the export was successful; < 0 if an error occurred 

<<<

[[crypto_ahash_import]]
*Name*

crypto_ahash_import — import message digest state

.Synopsis
[source,c]
------------
int crypto_ahash_import (struct ahash_request * req,
 	const void * in);
------------
 
*Arguments*

req::
    reference to ahash_request handle the state is imported into 
in::
    buffer holding the state 

*Description*

This function imports the hash state into the ahash_request handle from the input buffer. That buffer should have been generated with the crypto_ahash_export function.

*Return*

0 if the import was successful; < 0 if an error occurred 

<<<

=== Asynchronous Hash Request Handle

<<ahash_request_set_tfm, ahash_request_set_tfm>> — update cipher handle reference in request +
<<ahash_request_alloc, ahash_request_alloc>> — allocate request data structure +
<<ahash_request_free, ahash_request_free>> — zeroize and free the request data structure +
<<ahash_request_set_callback, ahash_request_set_callback>> — set asynchronous callback function +
<<ahash_request_set_crypt, ahash_request_set_crypt>> — set data buffers

The ahash_request data structure contains all pointers to data required for the asynchronous cipher operation. This includes the cipher handle (which can be used by multiple ahash_request instances), pointer to plaintext and the message digest output buffer, asynchronous callback function, etc. It acts as a handle to the ahash_request_* API calls in a similar way as ahash handle to the crypto_ahash_* API calls. 

<<< 

[[ahash_request_set_tfm]]
*Name*

ahash_request_set_tfm — update cipher handle reference in request

.Synopsis
[source,c]
------------
void ahash_request_set_tfm (struct ahash_request * req,
 	struct crypto_ahash * tfm);
------------
 
*Arguments*

req::
    request handle to be modified 
tfm::
    cipher handle that shall be added to the request handle 

*Description*

Allow the caller to replace the existing ahash handle in the request data structure with a different one. 

<<<

[[ahash_request_alloc]]
*Name*

ahash_request_alloc — allocate request data structure

.Synopsis
[source,c]
------------
struct ahash_request * ahash_request_alloc (struct crypto_ahash * tfm,
 	gfp_t gfp);
------------
 
*Arguments*

tfm::
    cipher handle to be registered with the request 
gfp::
    memory allocation flag that is handed to kmalloc by the API call. 

*Description*

Allocate the request data structure that must be used with the ahash message digest API calls. During the allocation, the provided ahash handle is registered in the request data structure.

*Return*

allocated request handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[ahash_request_free]]
*Name*

ahash_request_free — zeroize and free the request data structure

.Synopsis
[source,c]
------------
void ahash_request_free (struct ahash_request * req);
------------
 
*Arguments*

req::
    request data structure cipher handle to be freed 

<<<

[[ahash_request_set_callback]]
*Name*

ahash_request_set_callback — set asynchronous callback function

.Synopsis
[source,c]
------------
void ahash_request_set_callback (struct ahash_request * req,
 	u32 flags,
 	crypto_completion_t compl,
 	void * data);
------------
 
*Arguments*

req::
    request handle 
flags::
    specify zero or an ORing of the flags CRYPTO_TFM_REQ_MAY_BACKLOG the request queue may back log and increase the wait queue beyond the initial maximum size; CRYPTO_TFM_REQ_MAY_SLEEP the request processing may sleep 
compl::
    callback function pointer to be registered with the request handle 
data::
    The data pointer refers to memory that is not used by the kernel crypto API, but provided to the callback function for it to use. Here, the caller can provide a reference to memory the callback function can operate on. As the callback function is invoked asynchronously to the related functionality, it may need to access data structures of the related functionality which can be referenced using this pointer. The callback function can access the memory via the “data” field in the crypto_async_request data structure provided to the callback function. 

*Description*

This function allows setting the callback function that is triggered once the cipher operation completes.

The callback function is registered with the ahash_request handle and must comply with the following template

[source,c]
--------------
void callback_function(struct crypto_async_request *req, int error) 
--------------

<<<

[[ahash_request_set_crypt]]
*Name*

ahash_request_set_crypt — set data buffers

.Synopsis
[source,c]
------------
void ahash_request_set_crypt (struct ahash_request * req,
 	struct scatterlist * src,
 	u8 * result,
 	unsigned int nbytes);
------------
 
*Arguments*

req::
    ahash_request handle to be updated 
src::
    source scatter/gather list 
result::
    buffer that is filled with the message digest -- the caller must ensure that the buffer has sufficient space by, for example, calling crypto_ahash_digestsize 
nbytes::
    number of bytes to process from the source scatter/gather list 

*Description*

By using this call, the caller references the source scatter/gather list. The source scatter/gather list points to the data the message digest is to be calculated for. 

<<<

=== Synchronous Message Digest API

<<crypto_alloc_shash, crypto_alloc_shash>> — allocate message digest handle +
<<crypto_free_shash, crypto_free_shash>> — zeroize and free the message digest handle +
<<crypto_shash_blocksize, crypto_shash_blocksize>> — obtain block size for cipher +
<<crypto_shash_digestsize, crypto_shash_digestsize>> — obtain message digest size +
<<crypto_shash_descsize, crypto_shash_descsize>> — obtain the operational state size +
<<crypto_shash_setkey, crypto_shash_setkey>> — set key for message digest +
<<crypto_shash_digest, crypto_shash_digest>> — calculate message digest for buffer +
<<crypto_shash_export, crypto_shash_export>> — extract operational state for message digest +
<<crypto_shash_import, crypto_shash_import>> — import operational state +
<<crypto_shash_init, crypto_shash_init>> — (re)initialize message digest +
<<crypto_shash_update, crypto_shash_update>> — add data to message digest for processing +
<<crypto_shash_final, crypto_shash_final>> — calculate message digest +
<<crypto_shash_finup, crypto_shash_finup>> — calculate message digest of buffer

The synchronous message digest API is used with the ciphers of type CRYPTO_ALG_TYPE_SHASH (listed as type “shash” in /proc/crypto)

The message digest API is able to maintain state information for the caller.

The synchronous message digest API can store user-related context in in its shash_desc request data structure. 

<<<

[[crypto_alloc_shash]]
*Name*

crypto_alloc_shash — allocate message digest handle

.Synopsis
[source,c]
------------
struct crypto_shash * crypto_alloc_shash (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
  is the cra_name / name or cra_driver_name / driver name of the message digest cipher 
type::
  specifies the type of the cipher 
mask::
  specifies the mask for the cipher 

*Description*

Allocate a cipher handle for a message digest. The returned struct crypto_shash is the cipher handle that is required for any subsequent API invocation for that message digest.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_free_shash]]
*Name*

crypto_free_shash — zeroize and free the message digest handle

.Synopsis
[source,c]
------------
void crypto_free_shash (struct crypto_shash * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_shash_blocksize]]
*Name*

crypto_shash_blocksize — obtain block size for cipher

.Synopsis
[source,c]
------------
unsigned int crypto_shash_blocksize (struct crypto_shash * tfm);
------------
 
*Arguments*

tfm::
  cipher handle 

*Description*

The block size for the message digest cipher referenced with the cipher handle is returned.

*Return*

block size of cipher 

<<<

[[crypto_shash_digestsize]]
*Name*

crypto_shash_digestsize — obtain message digest size

.Synopsis
[source,c]
------------
unsigned int crypto_shash_digestsize (struct crypto_shash * tfm);
------------
 
*Arguments*

tfm::
  cipher handle 

*Description*

The size for the message digest created by the message digest cipher referenced with the cipher handle is returned.

*Return*

digest size of cipher 

<<<

[[crypto_shash_descsize]]
*Name*

crypto_shash_descsize — obtain the operational state size

.Synopsis
[source,c]
------------
unsigned int crypto_shash_descsize (struct crypto_shash * tfm);
------------
 
*Arguments*

tfm::
  cipher handle 

*Description*

The size of the operational state the cipher needs during operation is returned for the hash referenced with the cipher handle. This size is required to calculate the memory requirements to allow the caller allocating sufficient memory for operational state.

The operational state is defined with struct shash_desc where the size of that data structure is to be calculated as sizeof(struct shash_desc) + crypto_shash_descsize(alg)

*Return*

size of the operational state 

<<<

[[crypto_shash_setkey]]
*Name*

crypto_shash_setkey — set key for message digest

.Synopsis
[source,c]
------------
int crypto_shash_setkey (struct crypto_shash * tfm,
 	const u8 * key,
 	unsigned int keylen);
------------
 
*Arguments*

tfm::
  cipher handle 
key::
  buffer holding the key 
keylen::
  length of the key in bytes 

*Description*

The caller provided key is set for the keyed message digest cipher. The cipher handle must point to a keyed message digest cipher in order for this function to succeed.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred

<<<

[[crypto_shash_digest]]
*Name*

crypto_shash_digest — calculate message digest for buffer

.Synopsis
[source,c]
------------
int crypto_shash_digest (struct shash_desc * desc,
 	const u8 * data,
 	unsigned int len,
 	u8 * out);
------------
 
*Arguments*

desc::
    see crypto_shash_final 
data::
    see crypto_shash_update 
len::
    see crypto_shash_update 
out::
    see crypto_shash_final 

*Description*

This function is a “short-hand” for the function calls of crypto_shash_init, crypto_shash_update and crypto_shash_final. The parameters have the same meaning as discussed for those separate three functions.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_shash_export]]
*Name*

crypto_shash_export — extract operational state for message digest

.Synopsis
[source,c]
------------
int crypto_shash_export (struct shash_desc * desc,
 	void * out);
------------
 
*Arguments*

desc::
    reference to the operational state handle whose state is exported 
out::
    output buffer of sufficient size that can hold the hash state 

*Description*

This function exports the hash state of the operational state handle into the caller-allocated output buffer out which must have sufficient size (e.g. by calling crypto_shash_descsize).

*Return*

0 if the export creation was successful; < 0 if an error occurred 

<<<

[[crypto_shash_import]]
*Name*

crypto_shash_import — import operational state

.Synopsis
[source,c]
------------
int crypto_shash_import (struct shash_desc * desc,
 	const void * in);
------------
 
*Arguments*

desc::
    reference to the operational state handle the state imported into 
in::
    buffer holding the state 

*Description*

This function imports the hash state into the operational state handle from the input buffer. That buffer should have been generated with the crypto_ahash_export function.

*Return*

0 if the import was successful; < 0 if an error occurred 

<<<

[[crypto_shash_init]]
*Name*

crypto_shash_init — (re)initialize message digest

.Synopsis
[source,c]
------------
int crypto_shash_init (struct shash_desc * desc);
------------
 
*Arguments*

desc::
    operational state handle that is already filled 

*Description*

The call (re-)initializes the message digest referenced by the operational state handle. Any potentially existing state created by previous operations is discarded.

*Return*

0 if the message digest initialization was successful; < 0 if an error occurred 

<<<

[[crypto_shash_update]]
*Name*

crypto_shash_update — add data to message digest for processing

.Synopsis
[source,c]
------------
int crypto_shash_update (struct shash_desc * desc,
 	const u8 * data,
 	unsigned int len);
------------
 
*Arguments*

desc::
    operational state handle that is already initialized 
data::
    input data to be added to the message digest 
len::
    length of the input data 

*Description*

Updates the message digest state of the operational state handle.

*Return*

0 if the message digest update was successful; < 0 if an error occurred 

<<<

[[crypto_shash_final]]
*Name*

crypto_shash_final — calculate message digest

.Synopsis
[source,c]
------------
int crypto_shash_final (struct shash_desc * desc,
 	u8 * out);
------------
 
*Arguments*

desc::
    operational state handle that is already filled with data 
out::
    output buffer filled with the message digest 

*Description*

Finalize the message digest operation and create the message digest based on all data added to the cipher handle. The message digest is placed into the output buffer. The caller must ensure that the output buffer is large enough by using crypto_shash_digestsize.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

[[crypto_shash_finup]]
*Name*

crypto_shash_finup — calculate message digest of buffer

.Synopsis
[source,c]
------------
int crypto_shash_finup (struct shash_desc * desc,
 	const u8 * data,
 	unsigned int len,
 	u8 * out);
------------
 
*Arguments*

desc::
    see crypto_shash_final 
data::
    see crypto_shash_update 
len::
    see crypto_shash_update 
out::
    see crypto_shash_final 

*Description*

This function is a “short-hand” for the function calls of crypto_shash_update and crypto_shash_final. The parameters have the same meaning as discussed for those separate functions.

*Return*

0 if the message digest creation was successful; < 0 if an error occurred 

<<<

=== Crypto API Random Number API

<<crypto_alloc_rng, crypto_alloc_rng>> — - allocate RNG handle +
<<crypto_rng_alg, crypto_rng_alg>> — obtain name of RNG +
<<crypto_free_rng, crypto_free_rng>> — zeroize and free RNG handle +
<<crypto_rng_get_bytes, crypto_rng_get_bytes>> — get random number +
<<crypto_rng_reset, crypto_rng_reset>> — re-initialize the RNG +
<<crypto_rng_seedsize, crypto_rng_seedsize>> — obtain seed size of RNG

The random number generator API is used with the ciphers of type CRYPTO_ALG_TYPE_RNG (listed as type “rng” in /proc/crypto) 

<<<

[[crypto_alloc_rng]]
*Name*

crypto_alloc_rng — - allocate RNG handle

.Synopsis
[source,c]
------------
struct crypto_rng * crypto_alloc_rng (const char * alg_name,
 	u32 type,
 	u32 mask);
------------
 
*Arguments*

alg_name::
    is the cra_name / name or cra_driver_name / driver name of the message digest cipher 
type::
    specifies the type of the cipher 
mask::
    specifies the mask for the cipher 

*Description*

Allocate a cipher handle for a random number generator. The returned struct crypto_rng is the cipher handle that is required for any subsequent API invocation for that random number generator.

For all random number generators, this call creates a new private copy of the random number generator that does not share a state with other instances. The only exception is the “krng” random number generator which is a kernel crypto API use case for the get_random_bytes function of the /dev/random driver.

*Return*

allocated cipher handle in case of success; IS_ERR is true in case of an error, PTR_ERR returns the error code. 

<<<

[[crypto_rng_alg]]
*Name*

crypto_rng_alg — obtain name of RNG

.Synopsis
[source,c]
------------
struct rng_alg * crypto_rng_alg (struct crypto_rng * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

Return the generic name (cra_name) of the initialized random number generator

*Return*

generic name string 

<<<

[[crypto_free_rng]]
*Name*

crypto_free_rng — zeroize and free RNG handle

.Synopsis
[source,c]
------------
void crypto_free_rng (struct crypto_rng * tfm);
------------
 
*Arguments*

tfm::
    cipher handle to be freed 

<<<

[[crypto_rng_get_bytes]]
*Name*

crypto_rng_get_bytes — get random number

.Synopsis
[source,c]
------------
int crypto_rng_get_bytes (struct crypto_rng * tfm,
 	u8 * rdata,
 	unsigned int dlen);
------------
 
*Arguments*

tfm::
    cipher handle 
rdata::
    output buffer holding the random numbers 
dlen::
    length of the output buffer 

*Description*

This function fills the caller-allocated buffer with random numbers using the random number generator referenced by the cipher handle.
*Return*

\> 0 function was successful and returns the number of generated bytes; < 0 if an error occurred 

<<<

[[crypto_rng_reset]]
*Name*

crypto_rng_reset — re-initialize the RNG

.Synopsis
[source,c]
------------
int crypto_rng_reset (struct crypto_rng * tfm,
 	u8 * seed,
 	unsigned int slen);
------------
 
*Arguments*

tfm::
    cipher handle 
seed::
    seed input data 
slen::
    length of the seed input data 

*Description*

The reset function completely re-initializes the random number generator referenced by the cipher handle by clearing the current state. The new state is initialized with the caller provided seed or automatically, depending on the random number generator type (the ANSI X9.31 RNG requires caller-provided seed, the SP800-90A DRBGs perform an automatic seeding). The seed is provided as a parameter to this function call. The provided seed should have the length of the seed size defined for the random number generator as defined by crypto_rng_seedsize.

*Return*

0 if the setting of the key was successful; < 0 if an error occurred 

<<<

[[crypto_rng_seedsize]]
*Name*

crypto_rng_seedsize — obtain seed size of RNG

.Synopsis
[source,c]
------------
int crypto_rng_seedsize (struct crypto_rng * tfm);
------------
 
*Arguments*

tfm::
    cipher handle 

*Description*

The function returns the seed size for the random number generator referenced by the cipher handle. This value may be zero if the random number generator does not implement or require a reseeding. For example, the SP800-90A DRBGs implement an automated reseeding after reaching a pre-defined threshold.

*Return*

seed size for the random number generator 
